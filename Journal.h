/*
	CONTAINER FOR THE TRADES GENERATED BY THE STRATEGY
*/

#pragma once
#include <cmath>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "Dataset.h"
#include "Random.h"




using namespace std;

enum TradeType { longType, shortType };



class Parameters	//depend on the strategy thus defined there (these will be the predictors)
{
	public:

		virtual ~Parameters() {}
		virtual Parameters* clone() = 0;

		virtual vector<double> doubleTransform() const = 0;
		virtual string header() const = 0;
		virtual string dataText() const = 0;

};




class TradeInfo		//single trade
{
	private:
		
		//calculated by the strategy
		int tradeStart;

		TradeType type;
		double entry;
		double stop;
		double target;
		Parameters* parameters;

		double risk;		//in percent
		double leverage;
		double feeEntry;	//in capital percent
		

		//calculated by the finalize function
		double exit;
		double feeExit;		//in capital percent

		int tradeEnd;

		int duration;
		double funding;			//in capital percent
		double income;			//in capital percent

		double slippageLoss;	//in capital percent


	public:

		TradeInfo(TradeType type, double entry, double stop, double target, double feeEntry, Parameters* parameters, int tradeStart, double risk, double leverage,
			double exit, double feeExit, int tradeEnd, int duration, double funding, double income, double slippageLoss) : type(type), entry(entry), stop(stop), target(target),	
			feeEntry(feeEntry), parameters(parameters), tradeStart(tradeStart), risk(risk), leverage(leverage), exit(exit), feeExit(feeExit), tradeEnd(tradeEnd), duration(duration), 
			funding(funding), income(income), slippageLoss(slippageLoss)  {}		//receives everything as parameter
		TradeInfo(int tradeStart, TradeType type, double entry, double stop, double target, double risk, double leverage, Parameters* parameters, double fee, bool slippage,
			const Candle& slippageCandle = Candle(), double capital = 0, double slipRate = 0);		//calculates feeEntry and slippageLoss
		TradeInfo(const TradeInfo& other);		
		~TradeInfo() { delete parameters; }

		double getStop() const { return stop; }
		TradeType getType() const { return type; }
		double getEntry() const { return entry; }
		double getTarget() const { return target; }
		int getTradeStart() const { return tradeStart; }
		double getExit() const { return exit; }
		int getTradeEnd() const { return tradeEnd; }
		double getIncome() const { return income; }
		const Parameters* const getParameters() const { return parameters; }

		vector<double> getPredictors() const;		//as double values

		void setParameters(Parameters* newParameters);

		bool didFail(const Candle& lastCandle) const { return type == longType ? lastCandle.getLow() <= stop : lastCandle.getHigh() >= stop; }
		void finalize(const Dataset& myData, int index, double exitPrice, double fee, double fundingRate, bool slippage, double capital = 0, double slipRate = 0);

		TradeInfo operator=(const TradeInfo& other);

		friend ostream& operator<<(ostream& os, const TradeInfo& myTradeInfo);

		
};



class Journal
{

	private:

		vector<TradeInfo*> trades;

	public:

		Journal() {}
		Journal(const Journal& other);
		~Journal() { clear(); }

		int getSize() const { return static_cast<int>(trades.size()); }

		void addElement(const TradeInfo& tradeInfo) { trades.push_back(new TradeInfo(tradeInfo)); }
		void removeElement(int index);
		void clear();

		void randomSplit(int subsetSize, const string& fileName1, const string& fileName2) const;	//saves two random subsets to files (set1: subsetSize, set2: rest)

		const TradeInfo& operator[](int index) const;
		TradeInfo& operator[](int index);
		Journal& operator=(const Journal& other);
		
};


void saveTrades(const Journal& trades, const string& fileName);


